using ISynergy.Framework.Core.Extensions.Base;
using ISynergy.Framework.Core.Validation;
using System.Collections;
using System.Collections.ObjectModel;
using System.Data;

namespace ISynergy.Framework.Core.Extensions;

/// <summary>
/// Extensions for the <see cref="ICollection" /> and <see cref="Collection{T}" /> classes.
/// Provides utilities for collection manipulation, sorting, and conversion.
/// </summary>
public static class CollectionExtensions
{
    /// <summary>
    /// Generates a sequence by repeatedly applying a function starting from an initial value.
    /// Continues until the predicate returns false.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements.</typeparam>
    /// <param name="source">The initial value.</param>
    /// <param name="nextItem">Function to generate the next item.</param>
    /// <param name="canContinue">Predicate to determine if iteration should continue.</param>
    /// <returns>A sequence generated by repeatedly applying nextItem.</returns>
    public static IEnumerable<TSource> FromHierarchy<TSource>(
        this TSource source,
        Func<TSource, TSource> nextItem,
        Func<TSource, bool> canContinue)
    {
        for (var current = source; canContinue(current); current = nextItem(current))
        {
            yield return current;
        }
    }

    /// <summary>
    /// Generates a sequence by repeatedly applying a function starting from an initial value.
    /// Continues until a null value is encountered.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements (must be a reference type).</typeparam>
    /// <param name="source">The initial value.</param>
    /// <param name="nextItem">Function to generate the next item.</param>
    /// <returns>A sequence generated by repeatedly applying nextItem until null.</returns>
    public static IEnumerable<TSource> FromHierarchy<TSource>(
        this TSource source,
        Func<TSource, TSource> nextItem)
        where TSource : class
    {
        return FromHierarchy(source, nextItem, s => s is not null);
    }

    /// <summary>
    /// Determines whether the item can be moved up in the list.
    /// </summary>
    /// <param name="list">The list.</param>
    /// <param name="item">The item to check.</param>
    /// <returns><c>true</c> if the item can be moved up; otherwise, <c>false</c>.</returns>
    public static bool CanMoveItemUp(this IList list, object? item)
    {
        Argument.IsNotNull(list);
        return item is not null && list.Count > 1 && list.IndexOf(item) > 0;
    }

    /// <summary>
    /// Moves the specified item up in the list.
    /// </summary>
    /// <param name="list">The list.</param>
    /// <param name="item">The item to move up.</param>
    /// <returns><c>true</c> if successfully moved; otherwise, <c>false</c>.</returns>
    public static bool MoveItemUp(this IList list, object item)
    {
        Argument.IsNotNull(list);
        Argument.IsNotNull(item);

        var currentIndex = list.IndexOf(item);
        return currentIndex > 0 && MoveItemUpByIndex(list, currentIndex);
    }

    /// <summary>
    /// Determines whether the item can be moved down in the list.
    /// </summary>
    /// <param name="list">The list.</param>
    /// <param name="item">The item to check.</param>
    /// <returns><c>true</c> if the item can be moved down; otherwise, <c>false</c>.</returns>
    public static bool CanMoveItemDown(this IList list, object? item)
    {
        Argument.IsNotNull(list);
        
        if (item is null || list.Count <= 1)
            return false;

        var index = list.IndexOf(item);
        return index >= 0 && index < list.Count - 1;
    }

    /// <summary>
    /// Moves the item at the specified index up in the list.
    /// </summary>
    /// <param name="list">The list.</param>
    /// <param name="index">The index of the item to move up.</param>
    /// <returns><c>true</c> if successfully moved; otherwise, <c>false</c>.</returns>
    public static bool MoveItemUpByIndex(this IList list, int index)
    {
        Argument.IsNotNull(list);
        Argument.IsNotOutOfRange(index, 0, list.Count - 1);

        if (index <= 0)
            return index == 0; // Already at top

        var item = list[index];
        list.RemoveAt(index);
        list.Insert(index - 1, item);

        return true;
    }

    /// <summary>
    /// Moves the specified item down in the list.
    /// </summary>
    /// <param name="list">The list.</param>
    /// <param name="item">The item to move down.</param>
    /// <returns><c>true</c> if successfully moved; otherwise, <c>false</c>.</returns>
    public static bool MoveItemDown(this IList list, object item)
    {
        Argument.IsNotNull(list);
        Argument.IsNotNull(item);

        var currentIndex = list.IndexOf(item);
        return currentIndex >= 0 && currentIndex < list.Count - 1 && MoveItemDownByIndex(list, currentIndex);
    }

    /// <summary>
    /// Moves the item at the specified index down in the list.
    /// </summary>
    /// <param name="list">The list.</param>
    /// <param name="index">The index of the item to move down.</param>
    /// <returns><c>true</c> if successfully moved; otherwise, <c>false</c>.</returns>
    public static bool MoveItemDownByIndex(this IList list, int index)
    {
        Argument.IsNotNull(list);
        Argument.IsNotOutOfRange(index, 0, list.Count - 1);

        if (index >= list.Count - 1)
            return index == list.Count - 1; // Already at bottom

        var item = list[index];
        list.RemoveAt(index);
        list.Insert(index + 1, item);

        return true;
    }

    /// <summary>
    /// Adds a range of items to the collection.
    /// </summary>
    /// <typeparam name="T">Type of items within the collection.</typeparam>
    /// <param name="collection">The collection.</param>
    /// <param name="range">The items to add.</param>
    public static void AddRange<T>(this ICollection<T> collection, IEnumerable<T> range)
    {
        collection.EnsureNotNull();
        range.EnsureNotNull();

        foreach (var item in range)
        {
            collection.Add(item);
        }
    }

    /// <summary>
    /// Clears and adds a new range of items to the collection.
    /// </summary>
    /// <typeparam name="T">Type of items within the collection.</typeparam>
    /// <param name="collection">The collection.</param>
    /// <param name="range">The items to add.</param>
    public static void AddNewRange<T>(this ICollection<T> collection, IEnumerable<T> range)
    {
        collection.EnsureNotNull();
        collection.Clear();
        collection.AddRange(range);
    }

    /// <summary>
    /// Replaces all items in the collection with the specified range.
    /// </summary>
    /// <typeparam name="T">Type of items within the collection.</typeparam>
    /// <param name="collection">The collection.</param>
    /// <param name="range">The new items.</param>
    public static void ReplaceRange<T>(this ICollection<T> collection, IEnumerable<T> range)
    {
        Argument.IsNotNull(collection);
        Argument.IsNotNull(range);

        collection.Clear();
        AddRange(collection, range);
    }

    /// <summary>
    /// Removes the first entry from the list. Does nothing if the list is empty.
    /// </summary>
    /// <param name="list">The list.</param>
    public static void RemoveFirst(this IList list)
    {
        Argument.IsNotNull(list);

        if (list.Count > 0)
            list.RemoveAt(0);
    }

    /// <summary>
    /// Removes the last entry from the list. Does nothing if the list is empty.
    /// </summary>
    /// <param name="list">The list.</param>
    public static void RemoveLast(this IList list)
    {
        Argument.IsNotNull(list);

        if (list.Count > 0)
            list.RemoveAt(list.Count - 1);
    }

    /// <summary>
    /// Executes an action on each item in the enumerable.
    /// </summary>
    /// <typeparam name="T">Type of items.</typeparam>
    /// <param name="items">The items.</param>
    /// <param name="action">The action to execute.</param>
    public static void ForEach<T>(this IEnumerable<T>? items, Action<T> action)
    {
        if (items is null)
            return;

        foreach (var item in items)
            action(item);
    }

    /// <summary>
    /// Converts the list to a readonly collection.
    /// </summary>
    /// <typeparam name="T">Type of the items.</typeparam>
    /// <param name="collection">The collection to convert.</param>
    /// <returns>A readonly version of the collection.</returns>
    public static ReadOnlyCollection<T> AsReadOnly<T>(this IList<T> collection)
    {
        Argument.IsNotNull(collection);
        return new ReadOnlyCollection<T>(collection);
    }

    /// <summary>
    /// Converts the collection to an array of the specified element type.
    /// </summary>
    /// <param name="collection">The collection.</param>
    /// <param name="elementType">Type of the array elements.</param>
    /// <returns>An array containing the collection items.</returns>
    public static Array ToArray(this IEnumerable? collection, Type elementType)
    {
        Argument.IsNotNull(elementType);

        List<object> items;
        
        if (collection is null)
        {
            items = [];
        }
        else
        {
            items = collection.Cast<object>().ToList();
        }

        var array = Array.CreateInstance(elementType, items.Count);

        for (var i = 0; i < items.Count; i++)
        {
            array.SetValue(items[i], i);
        }

        return array;
    }

    /// <summary>
    /// Synchronizes the collection by adding/removing items to match the new set.
    /// </summary>
    /// <typeparam name="T">The type of the collection items.</typeparam>
    /// <param name="existingSet">The existing collection.</param>
    /// <param name="newSet">The new set of items.</param>
    /// <param name="updateExistingSet">If true, modifies the existing set; otherwise creates a new list.</param>
    /// <returns>The synchronized collection (existing set or new copy).</returns>
    public static IEnumerable<T> SynchronizeCollection<T>(
        this IList<T> existingSet,
        IEnumerable<T> newSet,
        bool updateExistingSet = true)
    {
        var finalSet = updateExistingSet ? existingSet : new List<T>(existingSet);
        var itemsToRemove = new HashSet<T>(existingSet);
        var itemsToAdd = new List<T>();

        foreach (var newItem in newSet.EnsureNotNull())
        {
            if (itemsToRemove.Contains(newItem))
            {
                itemsToRemove.Remove(newItem);
            }
            else
            {
                itemsToAdd.Add(newItem);
            }
        }

        foreach (var itemToRemove in itemsToRemove)
        {
            finalSet.Remove(itemToRemove);
        }

        foreach (var itemToAdd in itemsToAdd)
        {
            finalSet.Add(itemToAdd);
        }

        return finalSet;
    }

    /// <summary>
    /// Sorts the collection using the specified comparer or default comparison.
    /// Uses bubble sort algorithm.
    /// </summary>
    /// <typeparam name="T">Type of elements.</typeparam>
    /// <param name="existingSet">The collection to sort.</param>
    /// <param name="comparer">Optional custom comparer. If null, uses default IComparable.</param>
    public static void Sort<T>(this IList<T> existingSet, Func<T, T, int>? comparer = null)
    {
        Argument.IsNotNull(existingSet);

        for (var i = existingSet.Count - 1; i >= 0; i--)
        {
            for (var j = 1; j <= i; j++)
            {
                var o1 = existingSet[j - 1];
                var o2 = existingSet[j];

                var shouldReshuffle = comparer is null
                    ? ((o1 as IComparable)?.CompareTo(o2) ?? 0) > 0
                    : comparer(o1, o2) > 0;

                if (shouldReshuffle)
                {
                    existingSet.RemoveAt(j - 1);
                    existingSet.Insert(j, o1);
                }
            }
        }
    }

    /// <summary>
    /// Converts the collection to a DataTable.
    /// </summary>
    /// <typeparam name="T">Type of items in the collection.</typeparam>
    /// <param name="collection">The collection to convert.</param>
    /// <param name="tableName">The name for the DataTable.</param>
    /// <returns>A DataTable representation of the collection.</returns>
    public static DataTable ToDataTable<T>(this ICollection<T> collection, string tableName) =>
        collection.ToDataTableBase<T>(tableName);

    /// <summary>
    /// Converts the collection to a DataTable.
    /// </summary>
    /// <param name="collection">The collection to convert.</param>
    /// <param name="type">The type of items in the collection.</param>
    /// <param name="tableName">The name for the DataTable.</param>
    /// <returns>A DataTable representation of the collection.</returns>
    public static DataTable ToDataTable(this ICollection collection, Type type, string tableName) =>
        collection.ToDataTableBase(tableName, type);
}
